"""Strategy interface protocols for FinBrickLab.

Defines the contracts that all strategies must satisfy.
"""
# ruff: noqa: ANN101  # Protocol methods don't need self type annotations

from __future__ import annotations

from typing import TYPE_CHECKING, Protocol, runtime_checkable

from .context import ScenarioContext
from .results import BrickOutput

if TYPE_CHECKING:
    # Only imported for type checking to avoid runtime cycles
    from .bricks import ABrick, FBrick, LBrick


@runtime_checkable
class IValuationStrategy(Protocol):
    """Contract for ASSET valuation strategies (family='a').

    This protocol defines the interface that all asset valuation strategies must implement.
    Asset strategies are responsible for producing asset values over time and any internal
    cash flows generated by the asset.

    **Use Cases:**
    - Cash accounts, investment portfolios, real estate
    - Any financial instrument that holds value over time
    - Assets that generate periodic cash flows (dividends, rent, interest)

    **Example Implementation:**
        ```python
        class ValuationCash(IValuationStrategy):
            def prepare(self, brick: ABrick, ctx: ScenarioContext) -> None:
                # Validate spec parameters, set up initial state
                assert "initial_balance" in brick.spec

            def simulate(self, brick: ABrick, ctx: ScenarioContext) -> BrickOutput:
                # Compute asset value and cash flows over time
                balance = np.full(len(ctx.t_index), brick.spec["initial_balance"])
                return BrickOutput(
                    cash_in=np.zeros(len(ctx.t_index)),
                    cash_out=np.zeros(len(ctx.t_index)),
                    asset_value=balance,
                    debt_balance=np.zeros(len(ctx.t_index)),
                    events=[]
                )
        ```

    **Responsibilities:**
    - Produce asset values over time
    - Handle any internal cash flows generated by the asset
    - Validate strategy-specific parameters in prepare()
    """

    def prepare(self, brick: ABrick, ctx: ScenarioContext) -> None:
        """Validate inputs, compute derived params, and initialize any internal state.

        Called exactly once before simulation.
        """
        ...

    def simulate(self, brick: ABrick, ctx: ScenarioContext) -> BrickOutput:
        """Run the full-period simulation for this asset brick.

        Returns:
            BrickOutput with fields:
                - cash_in:    np.ndarray[T]
                - cash_out:   np.ndarray[T]
                - asset_value: np.ndarray[T]
                - debt_balance: np.ndarray[T] (usually zeros for assets)
                - events:     list[Event]
        """
        ...


@runtime_checkable
class IScheduleStrategy(Protocol):
    """Contract for LIABILITY schedule strategies (family='l').

    Responsibilities: produce debt balances and payment schedules over time.
    """

    def prepare(self, brick: LBrick, ctx: ScenarioContext) -> None:
        """Validate inputs and initialize internal state prior to simulate()."""
        ...

    def simulate(self, brick: LBrick, ctx: ScenarioContext) -> BrickOutput:
        """Run the full-period schedule simulation.

        Returns:
            BrickOutput (same schema). For liabilities, debt_balance is populated;
            asset_value is typically zeros.
        """
        ...


@runtime_checkable
class IFlowStrategy(Protocol):
    """Contract for CASH FLOW strategies (family='f').

    This protocol defines the interface for cash flow strategies that generate external
    cash inflows and outflows over time. Flow strategies model income, expenses, and
    transfers that affect the overall cash position.

    **Use Cases:**
    - Salary, pension, rental income
    - Monthly expenses (rent, utilities, groceries)
    - One-time transfers (bonuses, tax refunds)
    - Periodic payments (insurance, subscriptions)

    **Example Implementation:**
        ```python
        class FlowIncomeFixed(IFlowStrategy):
            def prepare(self, brick: FBrick, ctx: ScenarioContext) -> None:
                # Validate required parameters
                assert "amount_monthly" in brick.spec

            def simulate(self, brick: FBrick, ctx: ScenarioContext) -> BrickOutput:
                # Generate monthly income
                monthly_income = brick.spec["amount_monthly"]
                cash_in = np.full(len(ctx.t_index), monthly_income)

                return BrickOutput(
                    cash_in=cash_in,
                    cash_out=np.zeros(len(ctx.t_index)),
                    asset_value=np.zeros(len(ctx.t_index)),
                    debt_balance=np.zeros(len(ctx.t_index)),
                    events=[]
                )
        ```

    **Responsibilities:**
    - Generate external cash inflows/outflows over time
    - Model periodic or one-time financial events
    - Validate flow-specific parameters in prepare()
    """

    def prepare(self, brick: FBrick, ctx: ScenarioContext) -> None:
        """Validate inputs and initialize internal state prior to simulate()."""
        ...

    def simulate(self, brick: FBrick, ctx: ScenarioContext) -> BrickOutput:
        """Run the full-period flow simulation.

        Returns:
            BrickOutput (same schema). For pure flows, asset_value/debt_balance are zeros.
        """
        ...


__all__ = ["IValuationStrategy", "IScheduleStrategy", "IFlowStrategy"]
