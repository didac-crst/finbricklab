# Brick Catalog YAML Syntax

This document defines the canonical YAML format for describing Brick catalogs. A
catalog captures reusable Asset/Liability/Flow/Transfer bricks (and optional
MacroBricks) that can be ingested into an `Entity` via
`Entity.ingest_catalog(...)`.

> **Parser availability** – YAML parsing requires `PyYAML>=6.0.3`. The package
> is part of the default `finbricklab` dependency set; for manual installs run
> `pip install PyYAML`.

## Top-level structure

```yaml
version: 1            # optional, defaults to 1
entity:               # optional metadata
  name: Family A
  base_currency: EUR
  assumptions:
    inflation: 0.02
defaults:             # optional section applied to every brick
  currency: EUR       # fallback currency when a brick omits it
  spec:               # merged (deep) into each brick spec
    tax_rate: 0.25
  links:              # merged (deep) into each brick links block
    route:
      to: cash_main
  window:             # merged with brick.window
    start: 2026-01-01
bricks:               # required list of brick definitions
  - ...
macrobricks:          # optional list of macro structures
  - ...
```

### Brick entries

Each item in `bricks` accepts the following keys:

| Field | Required | Description |
| --- | --- | --- |
| `name` | ✓ | Human label used for autogenerated IDs when `id` omitted |
| `id` |  | Override identifier (slugified name otherwise) |
| `kind` | ✓ | Strategy discriminator (e.g. `a.cash`, `l.loan.annuity`) |
| `currency` |  | ISO code (defaults to `defaults.currency` or entity base) |
| `spec` | ✓ | Strategy specific payload; deep-merged with `defaults.spec` |
| `links` |  | Relationship hints (principal, route, …); merged with `defaults.links` |
| `window.start` |  | ISO date activating the brick |
| `window.end` |  | ISO date deactivating the brick (inclusive) |
| `window.duration_m` |  | Alternative to `end`; positive integer months |
| `transparent` | T bricks only | Overrides default transparency for transfers |
| `notes` |  | Arbitrary string metadata retained in the catalog output |

Family is inferred from `kind` (`a./l./f./t.` prefixes). The loader deep copies
`spec`/`links` before handing them to the builder methods.

### MacroBrick entries

`macrobricks` is optional. Each entry contains:

| Field | Required | Description |
| --- | --- | --- |
| `name` | ✓ | Label used for auto IDs |
| `id` |  | Optional override |
| `members` | ✓ | List of brick or MacroBrick IDs (can reference later macros) |
| `tags` |  | List of tag strings |

Membership validation occurs after ingestion (`Registry.validate`) so macros may
reference other macros defined later in the catalog. Cycles still raise during
validation.

## Example catalog

- A minimal runnable template ships with the repository: `examples/catalogs/starter.yaml`.
  Load it via `entity.ingest_catalog("examples/catalogs/starter.yaml")` to experiment
  with a pre-built cash / income / expense / liability portfolio.

```yaml
version: 1
entity:
  name: Rivera Household
  base_currency: EUR
defaults:
  currency: EUR
  links:
    route:
      to: cash_main
  window:
    start: 2026-01-01
bricks:
  - id: cash_main
    name: Main Cash
    kind: a.cash
    spec:
      initial_balance: 20000
  - name: Brokerage
    kind: a.security.unitized
    spec:
      initial_units: 50
      price0: 100
  - name: Home Purchase
    id: house
    kind: a.property
    spec:
      initial_value: 450000
      fees_pct: 0.09
      appreciation_pa: 0.02
  - name: Mortgage
    kind: l.loan.annuity
    spec:
      principal: 360000
      rate_pa: 0.036
      term_months: 300
    links:
      principal:
        from_house: house
    window:
      start: 2026-06-01
  - name: Salary
    kind: f.income.recurring
    spec:
      amount_monthly: 6000
      tax_rate: 0.3
  - name: Brokerage DCA
    kind: t.transfer.recurring
    spec:
      amount_monthly: 1200
    links:
      route:
        from: cash_main
        to: brokerage
    transparent: false
macrobricks:
  - name: Housing Stack
    id: housing
    members: [house, mortgage]
  - name: Portfolio
    members: [cash_main, brokerage, housing]
    tags: [net-worth]
```

## Entity ingestion

```python
from finbricklab.core.entity import Entity
import finbricklab.strategies  # ensure registries are wired

entity = Entity(name="Rivera Household")
summary = entity.ingest_catalog("catalog.yaml")
print(summary["bricks"])        # ['cash_main', 'brokerage', ...]
print(summary["macrobricks"])   # ['housing', 'portfolio']
```

`ingest_catalog` returns the created IDs plus catalog metadata. The method
automatically runs `Registry` validation when new MacroBricks are registered.
