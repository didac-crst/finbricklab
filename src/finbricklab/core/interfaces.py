"""Strategy interface protocols for FinBrickLab.

Defines the contracts that all strategies must satisfy.
"""
# ruff: noqa: ANN101  # Protocol methods don't need self type annotations

from __future__ import annotations

from typing import TYPE_CHECKING, Protocol, runtime_checkable

from .context import ScenarioContext
from .results import BrickOutput

if TYPE_CHECKING:
    # Only imported for type checking to avoid runtime cycles
    from .bricks import ABrick, FBrick, LBrick, TBrick


@runtime_checkable
class IValuationStrategy(Protocol):
    """Contract for ASSET valuation strategies (family='a').

    This protocol defines the interface that all asset valuation strategies must implement.
    Asset strategies are responsible for producing asset values over time and any internal
    cash flows generated by the asset.

    **Use Cases:**
    - Cash accounts, investment portfolios, real estate
    - Any financial instrument that holds value over time
    - Assets that generate periodic cash flows (dividends, rent, interest)

    **Example Implementation:**
        ```python
        class ValuationCash(IValuationStrategy):
            def prepare(self, brick: ABrick, ctx: ScenarioContext) -> None:
                # Validate spec parameters, set up initial state
                assert "initial_balance" in brick.spec

            def simulate(self, brick: ABrick, ctx: ScenarioContext) -> BrickOutput:
                # Compute asset value and cash flows over time
                balance = np.full(len(ctx.t_index), brick.spec["initial_balance"])
                return BrickOutput(
                    cash_in=np.zeros(len(ctx.t_index)),
                    cash_out=np.zeros(len(ctx.t_index)),
                    asset_value=balance,
                    debt_balance=np.zeros(len(ctx.t_index)),
                    events=[]
                )
        ```

    **Responsibilities:**
    - Produce asset values over time
    - Handle any internal cash flows generated by the asset
    - Validate strategy-specific parameters in prepare()
    """

    def prepare(self, brick: ABrick, ctx: ScenarioContext) -> None:
        """Validate inputs, compute derived params, and initialize any internal state.

        Called exactly once before simulation.
        """
        ...

    def simulate(self, brick: ABrick, ctx: ScenarioContext) -> BrickOutput:
        """Run the full-period simulation for this asset brick.

        Returns:
            BrickOutput with fields:
                - cash_in:    np.ndarray[T]
                - cash_out:   np.ndarray[T]
                - asset_value: np.ndarray[T]
                - debt_balance: np.ndarray[T] (usually zeros for assets)
                - events:     list[Event]
        """
        ...


@runtime_checkable
class IScheduleStrategy(Protocol):
    """Contract for LIABILITY schedule strategies (family='l').

    Responsibilities: produce debt balances and payment schedules over time.
    """

    def prepare(self, brick: LBrick, ctx: ScenarioContext) -> None:
        """Validate inputs and initialize internal state prior to simulate()."""
        ...

    def simulate(self, brick: LBrick, ctx: ScenarioContext) -> BrickOutput:
        """Run the full-period schedule simulation.

        Returns:
            BrickOutput (same schema). For liabilities, debt_balance is populated;
            asset_value is typically zeros.
        """
        ...


@runtime_checkable
class IFlowStrategy(Protocol):
    """Contract for CASH FLOW strategies (family='f').

    This protocol defines the interface for cash flow strategies that generate external
    cash inflows and outflows over time. Flow strategies model income, expenses, and
    transfers that affect the overall cash position.

    **Use Cases:**
    - Salary, pension, rental income
    - Monthly expenses (rent, utilities, groceries)
    - One-time transfers (bonuses, tax refunds)
    - Periodic payments (insurance, subscriptions)

    **Example Implementation:**
        ```python
        class FlowIncomeFixed(IFlowStrategy):
            def prepare(self, brick: FBrick, ctx: ScenarioContext) -> None:
                # Validate required parameters
                assert "amount_monthly" in brick.spec

            def simulate(self, brick: FBrick, ctx: ScenarioContext) -> BrickOutput:
                # Generate monthly income
                monthly_income = brick.spec["amount_monthly"]
                cash_in = np.full(len(ctx.t_index), monthly_income)

                return BrickOutput(
                    cash_in=cash_in,
                    cash_out=np.zeros(len(ctx.t_index)),
                    asset_value=np.zeros(len(ctx.t_index)),
                    debt_balance=np.zeros(len(ctx.t_index)),
                    events=[]
                )
        ```

    **Responsibilities:**
    - Generate external cash inflows/outflows over time
    - Model periodic or one-time financial events
    - Validate flow-specific parameters in prepare()
    """

    def prepare(self, brick: FBrick, ctx: ScenarioContext) -> None:
        """Validate inputs and initialize internal state prior to simulate()."""
        ...

    def simulate(self, brick: FBrick, ctx: ScenarioContext) -> BrickOutput:
        """Run the full-period flow simulation.

        Returns:
            BrickOutput (same schema). For pure flows, asset_value/debt_balance are zeros.
        """
        ...


@runtime_checkable
class ITransferStrategy(Protocol):
    """Contract for TRANSFER strategies (family='t').

    This protocol defines the interface for transfer strategies that move money
    between internal accounts without affecting net worth. Transfer strategies
    model internal movements of funds within the system.

    **Use Cases:**
    - Moving money between checking and savings accounts
    - Transferring funds between investment accounts
    - Internal rebalancing of portfolios
    - Scheduled transfers (monthly savings, etc.)

    **Example Implementation:**
        ```python
        class TransferLumpSum(ITransferStrategy):
            def prepare(self, brick: TBrick, ctx: ScenarioContext) -> None:
                # Validate required parameters
                assert "amount" in brick.spec
                assert "from" in brick.links
                assert "to" in brick.links

            def simulate(self, brick: TBrick, ctx: ScenarioContext) -> BrickOutput:
                # Generate transfer at specified time
                amount = brick.spec["amount"]
                transfer_time = brick.window.start_date

                return BrickOutput(
                    cash_in=np.zeros(len(ctx.t_index)),
                    cash_out=np.zeros(len(ctx.t_index)),
                    asset_value=np.zeros(len(ctx.t_index)),
                    debt_balance=np.zeros(len(ctx.t_index)),
                    events=[Event(transfer_time, "transfer", f"Transfer {amount}")]
                )
        ```

    **Responsibilities:**
    - Move money between internal accounts
    - Maintain zero net worth impact
    - Validate transfer-specific parameters in prepare()
    - Generate appropriate events for transfers
    """

    def prepare(self, brick: TBrick, ctx: ScenarioContext) -> None:
        """Validate inputs and initialize internal state prior to simulate()."""
        ...

    def simulate(self, brick: TBrick, ctx: ScenarioContext) -> BrickOutput:
        """Run the full-period transfer simulation.

        Returns:
            BrickOutput (same schema). For transfers, asset_value/debt_balance are zeros.
        """
        ...


__all__ = [
    "IValuationStrategy",
    "IScheduleStrategy",
    "IFlowStrategy",
    "ITransferStrategy",
]
